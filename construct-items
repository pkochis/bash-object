#!/usr/bin/env bash

################################################################################
# Script name: construct-items, Version 1.0
# This script is a part of "bash-object" project.
# https://github.com/pkochis/bash-object
# "bash-object" scripts are licensed under the GNU General Public License v3.0
# author: pal@kochis.hu
#
# A) Common routine: objLocalisedFile
# B) User routine handlers
# C) Delete user method and variable
# D) Object erase: deconstruct
# E) Add user variable
# F) Object help
# G) Add user method
# H) Copy reference
# I) Run objI in constructor
# J) Call basic-objects 
################################################################################
[[ $(type -t objC_construct) != function ]] && exit  # prevents unwanted run

# A) Common routine: objLocalisedFile
objLocalisedFile() {
 local language="${3:-${LANG:-${LC_CTYPE:-en}}}" ret=""
 (($# > 1)) && { [[ -e $1/locale/en/$2 ]] && ret="$1/locale/en/$2"; [[ -e $1/locale/${language%%_*}/$2 ]] && ret="$1/locale/${language%%_*}/$2"; }
 echo "$ret"; [[ -n $ret ]]
}; export -f objLocalisedFile

# B) User routine handlers
objR_RoutineNew() { ((${1:-0} > 10)) && eval function objR$1 "$2" && ((++obj_routines["N$1"])); }
objR_RoutineAdd() { ((${1:-0} > 10)) && ((++obj_routines["N$1"])); }
objR_RoutineRemove() { ((${1:-0} > 10 && --obj_routines["N$1"] < 1 )) && unset -v obj_routines["N$1"] && unset -f objR$1; }

# C) Delete method and variable
objC_delmethod() {
 [[ ${FUNCNAME[1]} != objC_* || -z ${this_methods["M$1"]} ]] && return  # protect this function
 objR_RoutineRemove ${this_methods["M$1"]}; unset -v this_methods["M$1"] this_public["M$1"]  # remove method
}
objC_delvariable() {
 [[ ${FUNCNAME[1]} != objC_* ]] && return  # protect this function
 unset -v objV_${this_data[V$1]} this_data[V$1]  # remove variable
}

# D) Object erase: deconstruct
obj_construct_end+=(obj_erase)
objRdeconstruct() { local i
 for i in "${this_methods[@]}"; do objR_RoutineRemove $i; done  # detach all method from routines
 for i in "${this_data[@]}"; do unset -v objV_$i; done  # remove all variables
 for i in "${obj_meta[@]}"; do unset -v obj_${i}$this; done; unset -v objects["ID${this[1]}"]  # delete object
}
objC_obj_erase() {
 [[ ${FUNCNAME[1]} != objC_end ]] && return  # protect this function
 [[ ${obj_construct_flag[obj-erase]} == no ]] && objC_delmethod obj-erase || \
  this_methods+=(["Mobj-erase"]=deconstruct) this_public+=(["Mobj-erase"]=deconstruct)
}
objC_noerase() {
 [[ ${FUNCNAME[1]} != objC_construct ]] && return  # protect this function
 obj_construct_flag+=([obj-erase]=no)  # set flag
}

# F) Add variable
objC_variable() {
 [[ ${FUNCNAME[1]} != objC_* ]] && return  # protect this function
 ((++obj_C)); unset -v objV_${this_data[V$1]} this_data[V$1]  # increase upcounter and remove variable
 (($# == 2)) && declare $2 objV_${obj_C}  # only declare
 (($# == 4)) && {
  [[ $1 != @(*a*|*A*) ]] && eval "declare $2 objV_${obj_C}=\"$4\""  # variable with value
  [[ $1 == @(*a*|*A*) ]] && eval "declare $2 objV_${obj_C}=$4"  # array with value
 }
 (($# == 3)) && {
  declare -n ref_data=obj_data$ref; local v=${ref_data[V$3]}  # check reference
  local att val; val="$(declare -p objV_$v 2> /dev/nul)" && {
   att="${val#declare }" att="${att%% *}" att="${att/--/-}g"  # read attribute of variable
   [[ $val != *=* ]] && eval "declare $att obj_v${obj_C}"  # only declared variable
   [[ $val == *=* && $att != @(*a*|*A*) ]] && eval "declare $att objV_${obj_C}=\"${val#*=}\""  # variable with value
   [[ $val == *=* && $att == @(*a*|*A*) ]] && eval "declare $att objV_${obj_C}=${val#*=}"  # array with value
  }
 }
 declare -p objV_${obj_C} &> /dev/nul && this_data+=([V$1]=${obj_C}) || ((obj_C--))  # check the new variable and register to object data
}

# F) Object help
obj_construct_end+=(obj_help)
objRhelp() { [[ -e ${obj_helpfile}.$1.help ]] && source "${obj_helpfile}.$1.help" || source "${obj_helpfile}.help"; }
objC_obj_help() { local i h=""
 [[ ${FUNCNAME[1]} != objC_end ]] && return  # protect this function
 for ((i=0; i<${#FUNCNAME}; i++)); do
  [[ ${FUNCNAME[$i]} != @(source|main) ]] && continue
  h="$(objLocalisedFile "$(objParentPath "${BASH_SOURCE[$i]}")" "${this[1]}.help")"; break
 done
 ((${#h} == 0)) && { objC_delmethod "--help"; objC_delvariable obj_helpfile; return; }
 this_methods+=(["M--help"]=help) this_public+=(["M--help"]=help); objC_variable obj_helpfile -g = "${h%.help}"
 [[ "${obj_construct_flag[obj-defaulthelp]}" == "yes" ]] && this_methods+=(["Mdefault"]=help) this_public+=(["Mdefault"]=help)
}
objC_defaulthelp() {
 [[ ${FUNCNAME[1]} != objC_construct ]] && return  # protect this function
 obj_construct_flag+=([obj-defaulthelp]=yes)  # set flag
}

# G) Add user method
objC_public() {
 [[ ${FUNCNAME[1]} != objC_* ]] && return  # protect this function
 objC_private "$@"; [[ -n ${this_methods["M$1"]} ]] && this_public+=(["M$1"]=${this_methods["M$1"]})  # call private and set public
}
objC_private() {
 [[ ${FUNCNAME[1]} != objC_* ]] && return  # protect this function
 unset -v this_methods["M$1"]  # reset public
 (($# == 2)) && {
  objC_delmethod "$1"  # remove old routine
  objR_RoutineNew $((++obj_C)) "$2" && this_methods+=(["M$1"]=${obj_C})  # add new routine
 }
 (($# == 3)) && {
  declare -n ref_methods=obj_methods$ref; local m=${ref_methods["M$3"]}  # check reference
  [[ "${this_methods["M$1"]}"  == "$m" ]] && return; objC_delmethod "$1"  # remove old routine
  [[ -n $m ]] && { objR_RoutineAdd $m; this_methods+=(["M$1"]=${ref_methods["M$3"]}); }  # add routine from reference
 }
}

# H) Copy reference
objC_copyreference() {
 [[ ${FUNCNAME[1]} != objC_* ]] && return  # protect this function
 local i; for i in "${obj_meta[@]}"; do declare -n ref_${i}=obj_${i}$ref; done  # pick reference object
 for i in "${!ref_data[@]}"; do objC_variable "${i:1}" reference "${i:1}"; done # copy variables
 for i in "${!ref_methods[@]}"; do objC_private "${i:1}" reference "${i:1}"; done # copy methods
 for i in "${!ref_public[@]}"; do this_public+=(["$i"]=${ref_public["$i"]}); done  # copy public
}

# I) Run objI in constructor
objC_init() {
 [[ ${FUNCNAME[1]} != objC_* ]] && return  # protect this function
 for i in "${!this_data[@]}"; do declare -n ${i:1}=objV_${this_data[$i]}; done; objI "$@"  # attach variables and run a method of the new object
}

# J) Call basic-objects 
source "${obj_HOME}/basic-objects"
