#!/usr/bin/env bash

################################################################################
# Script name: init, Version 1.0
# This script is a part of "bash-object" project.
# https://github.com/pkochis/bash-object
# "bash-object" scripts are licensed under the GNU General Public License v3.0
# author: pal@kochis.hu
#
# A) Set environment
# B) Message handlers
# C) Hidden object: obj-check
# D) Create object/class
# E) Call construct-items
################################################################################
[[ $(type -t obj) != function ]] && exit  # prevents unwanted run

# A) Set environment
declare -g obj_C; ((obj_C < 10)) && obj_C=12; export obj_C  # init general upcounter
declare -gA objects obj_routines  # init the registers of objects/classes and routines
declare -ga obj_meta=(public methods data)  # metadata for all objects/classes
declare -gA obj_methods0=() obj_public0=() obj_data0=()  # init the zero class
declare -gA obj_methods1=() obj_public1=() obj_data1=(); objects+=([ID::]=1)  # init the root class
declare -ga obj_construct_end=()  # init last processes for constructor

# B) Message handlers
objRerror() { local i c=0 et="$1"; shift; for i in "$@"; do ((c++)); et="${et//%A${c}%/$i}"; done; echo "$et"; }
obj() {
 declare -a this=(${objects["ID${1}"]:-2} "${1}" "${2:-default}" "${2:-default}" "${2:-default}"); shift; shift  # get ID of object/class
 local i; for i in "${obj_meta[@]}"; do declare -n this_$i=obj_${i}$this; done  # load object/class
 for i in "${!this_data[@]}"; do declare -n ${i:1}=objV_${this_data[$i]}; done  # attach variables
 objR${this_public["M${this[2]}"]:-check} "$@"
}
objI() { this[3]="${1:-default}" this[4]="${1:-default}"; shift; objR${this_methods["M${this[3]}"]:-checkI} "$@"; }
objRcheck() {
 ((${#this[1]} * ${#objects[@]} > 0)) && { objRtryPublicDefault "$@"; return; }
 source "${obj_INIT}" && ((${#this[1]} > 0)) && obj "${this[1]}" "${this[2]}" "$@"
}
objRcheckI() {
 ((${#this[1]} * ${#objects[@]} > 0)) && { objRtryDefault "$@"; return; }
 source "${obj_INIT}" && ((${#this[1]} > 0)) && objI "${this[3]}" "$@"
}
objRtryPublicDefault() { this[2]=default this[3]=default; objR${this_public[Mdefault]:-noPublicMethod} "${this[4]}" "$@"; }
objRtryDefault() { this[3]=default; objR${this_method[Mdefault]:-noMethod} "${this[4]}" "$@"; }
objRnoPublicMethod() { objRerror "The %A1% public method in %A2% object/class does not exist" "\"$1\"" "\"${this[1]}\""; }
objRnoMethod() { objRerror "The %A1% method in %A2% object/class does not exist" "\"$1\"" "\"${this[1]}\""; }
export -f objRerror obj objI objRcheck objRcheckI objRtryPublicDefault objRtryDefault objRnoPublicMethod objRnoMethod

# C) Hidden object: obj-check
declare -gA obj_public2+=([Mdefault]=notObject ["Mobj-create"]=create) obj_methods2=([Mdefault]=notObject ["Mobj-create"]=create) obj_data2=()
objRnotObject() { ((${#this[1]} > 0)) && objRerror "The %A1% object/class does not exist" "\"${this[1]}\"" || source "${obj_INIT}"; } 

# D) Create object/class
objRcreate() {
 (($this != 2)) && return; local ref i  # protect this function
 if [[ ${objects["ID$1"]:-0} -gt 0 && $1 == ::* ]]; then
  [[ ${this[1]} == ::* && "$1" != "::" ]] && this[1]="$1${this[1]}"  # create new class name
  objects+=(["ID${this[1]}"]="$((++obj_C))") this=${obj_C} ref=${objects["ID$1"]}; shift  # create and switch to ID of new object/class
  for i in "${obj_meta[@]}"; do declare -gA obj_${i}${obj_C}; declare -n this_${i}=obj_${i}${obj_C}; done  # init and switch to new object/class
  objC_construct : "$@" objC_end objC_  # develop the new object/class
 else
  objRerror "The %A1% is not a class" "\"$1\""
 fi
}  # objRcreate

objC_construct() {
 [[ ${FUNCNAME[1]} != objRcreate ]] && return  # protect this function
 declare -A obj_construct_flag=(); ref=0; declare -a cline=()  # flags for objC_end; reference object; command-line helper
 while (($# > 0)); do  # parse init command BEGIN
  [[ $1 == objC_* ]] && { "${cline[@]}"; cline=(); }; cline+=("$1"); shift  # create and run init routines in the init command
 done  # parse init command END
}
objC_reference() {
 [[ ${FUNCNAME[1]} != objC_* ]] && return  # protect this function
 ref=${objects["ID$1"]:-0}  # set reference (default is the zero class)
}
objC_end() {
 [[ ${FUNCNAME[1]} != objC_construct ]] && return; local i  # protect this function
 for i in "${obj_construct_end[@]}"; do objC_$i; done
 
 this_methods+=(["Mobj-create"]=create) this_public+=(["Mobj-create"]=create)  # allow reuse item of class name
}

# E) Call construct-items
source "${obj_HOME}/construct-items"
